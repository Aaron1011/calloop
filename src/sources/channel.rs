//! An MPSC channel whose receiving end is an event source
//!
//! Create a channel using `Channel::<T>::new()`, which returns a
//! `Sender<T>` that can be cloned and sent accross threads if `T: Send`,
//! and a `Channel<T>` that can be inserted into an `EventLoop`. It will generate
//! one event per message.

use std::cell::RefCell;
use std::rc::Rc;
use std::sync::{mpsc, Arc, Mutex};

use mio::{event::Event as MioEvent, Waker};

use crate::{EventDispatcher, EventSource};

/// The events generated by the channel event source
pub enum Event<T> {
    /// A message was received and is bundled here
    Msg(T),
    /// The channel was closed
    ///
    /// This means all the `Sender`s associated with this channel
    /// have been dropped, no more messages will ever be received.
    Closed,
}

/// The sender end of a channel
///
/// It can be cloned and sent accross threads (if `T` is).
pub struct Sender<T> {
    sender: mpsc::Sender<T>,
    waker: Arc<Mutex<Option<Arc<Waker>>>>,
}

impl<T> Clone for Sender<T> {
    fn clone(&self) -> Sender<T> {
        Sender {
            sender: self.sender.clone(),
            waker: self.waker.clone(),
        }
    }
}

impl<T> Sender<T> {
    /// Send a message to the channel
    ///
    /// This will wake the event loop and deliver an `Event::Msg` to
    /// it containing the provided value.
    pub fn send(&self, t: T) -> Result<(), mpsc::SendError<T>> {
        let g = self.waker.lock().unwrap();
        if let Some(ref w) = *g {
            let _ = w.wake();
        }
        self.sender.send(t)
    }
}

/// The sender end of a synchronous channel
///
/// It can be cloned and sent accross threads (if `T` is).
pub struct SyncSender<T> {
    sender: mpsc::SyncSender<T>,
    waker: Arc<Mutex<Option<Arc<Waker>>>>,
}

impl<T> Clone for SyncSender<T> {
    fn clone(&self) -> SyncSender<T> {
        SyncSender {
            sender: self.sender.clone(),
            waker: self.waker.clone(),
        }
    }
}

impl<T> SyncSender<T> {
    /// Send a message to the synchronous channel
    ///
    /// This will wake the event loop and deliver an `Event::Msg` to
    /// it containing the provided value. If the channel is full, this
    /// function will block until the event loop empties it and it can
    /// deliver the message. Readiness is signalled to the event loop
    /// *before* blocking.
    pub fn send(&self, t: T) -> Result<(), mpsc::SendError<T>> {
        let g = self.waker.lock().unwrap();
        if let Some(ref w) = *g {
            let _ = w.wake();
        }
        self.sender.send(t)
    }

    /// Send a message to the synchronous channel
    ///
    /// This will wake the event loop and deliver an `Event::Msg` to
    /// it containing the provided value. If the channel is full, this
    /// function will return an error. The event loop will be signalled
    /// for readinnes in all cases.
    pub fn try_send(&self, t: T) -> Result<(), mpsc::TrySendError<T>> {
        let g = self.waker.lock().unwrap();
        if let Some(ref w) = *g {
            let _ = w.wake();
        }
        self.sender.try_send(t)
    }
}

/// The receiving end of the channel
///
/// This is the event source to be inserted into your `EventLoop`.
pub struct Channel<T> {
    receiver: Rc<mpsc::Receiver<T>>,
    waker: Arc<Mutex<Option<Arc<Waker>>>>,
}

/// Create a new asynchronous channel
pub fn channel<T>() -> (Sender<T>, Channel<T>) {
    let (sender, receiver) = mpsc::channel();
    let waker = Arc::new(Mutex::new(None));
    (
        Sender {
            sender,
            waker: waker.clone(),
        },
        Channel {
            receiver: Rc::new(receiver),
            waker,
        },
    )
}

/// Create a new synchronous, bounded channel
pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Channel<T>) {
    let (sender, receiver) = mpsc::sync_channel(bound);
    let waker = Arc::new(Mutex::new(None));
    (
        SyncSender {
            sender,
            waker: waker.clone(),
        },
        Channel {
            receiver: Rc::new(receiver),
            waker,
        },
    )
}

impl<T: 'static> EventSource for Channel<T> {
    type Event = Event<T>;

    fn make_dispatcher<Data: 'static, F: FnMut(Event<T>, &mut Data) + 'static>(
        &mut self,
        callback: F,
        waker: &Arc<Waker>,
    ) -> Rc<RefCell<dyn EventDispatcher<Data>>> {
        *(self.waker.lock().unwrap()) = Some(waker.clone());
        Rc::new(RefCell::new(Dispatcher {
            _data: ::std::marker::PhantomData,
            receiver: self.receiver.clone(),
            callback,
        }))
    }
}

struct Dispatcher<Data, T, F: FnMut(Event<T>, &mut Data)> {
    _data: std::marker::PhantomData<fn(&mut Data)>,
    receiver: Rc<mpsc::Receiver<T>>,
    callback: F,
}

impl<Data, T, F: FnMut(Event<T>, &mut Data)> EventDispatcher<Data> for Dispatcher<Data, T, F> {
    fn ready(&mut self, _: Option<&MioEvent>, data: &mut Data) {
        loop {
            match self.receiver.try_recv() {
                Ok(val) => (self.callback)(Event::Msg(val), data),
                Err(mpsc::TryRecvError::Empty) => break,
                Err(mpsc::TryRecvError::Disconnected) => {
                    (self.callback)(Event::Closed, data);
                    break;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn basic_channel() {
        let mut event_loop = crate::EventLoop::new().unwrap();

        let handle = event_loop.handle();

        let (tx, rx) = channel::<()>();

        // (got_msg, got_closed)
        let mut got = (false, false);

        let _source = handle
            .insert_source(rx, move |evt, got: &mut (bool, bool)| match evt {
                Event::Msg(()) => {
                    got.0 = true;
                }
                Event::Closed => {
                    got.1 = true;
                }
            })
            .map_err(Into::<std::io::Error>::into)
            .unwrap();

        // nothing is sent, nothing is received
        event_loop
            .dispatch(Some(::std::time::Duration::from_millis(0)), &mut got)
            .unwrap();

        assert_eq!(got, (false, false));

        // a message is send
        tx.send(()).unwrap();
        event_loop
            .dispatch(Some(::std::time::Duration::from_millis(0)), &mut got)
            .unwrap();

        assert_eq!(got, (true, false));

        // the sender is dropped
        ::std::mem::drop(tx);
        event_loop
            .dispatch(Some(::std::time::Duration::from_millis(0)), &mut got)
            .unwrap();

        assert_eq!(got, (true, true));
    }
}
